#!/usr/bin/env node

//#######################################
// ~ load module and start server
var fs = require('fs-extra'); // FILE
var path = require('path');
var debug = require('debug')('vrcs');
var HashMap = require('hashmap').HashMap;

var Jpeg = require('jpeg').Jpeg; // JPEG
var Png = require('png').Png; // PNG

var app = require('../app');
var http = require('http');
var server = http.createServer(app);
var BinaryServer = require('binaryjs').BinaryServer; // BinaryJs (Byte stream)
var bs = BinaryServer({server : server}); // Start BinaryJs server
var io = require('socket.io').listen(server); // Socket.io
//#######################################

var CudaRender = require('../cuda/cuda_render').CudaRender;
//var CudaRender = require('../cuda/cuda_render2');

//#######################################
// ~ Wait for new user connections ( Implement Byte stream )
var frameList = [ 60, 50, 40, 30, 25, 20, 15, 10 ];
var streamMap = new HashMap();
var useMap = new HashMap();
var vrcsCudaMap = new HashMap();
var vrcsBufMap = new HashMap();

bs.on('connection', function(client){

    client.on('stream', function(stream, meta){
        console.log('byte stream connect attempt ' + client.id);
        var cudaInterval = function () {
            // TODO selection png or jpeg ( make this part function)
            var cudaRender = vrcsCudaMap.get(client.id);
            if(cudaRender == undefined){
                return;
            }

            var stack = vrcsBufMap.get(client.id);
            if(stack == undefined){
                return;
            }
            var hrstart = process.hrtime();
            cudaRender.start();
            //stack.push(cudaRender.d_outputBuffer);
            var jpeg = new Jpeg(cudaRender.d_outputBuffer, 512, 512, 'rgba');
            client.send(jpeg.encodeSync());
            cudaRender.end();
            hrend = process.hrtime(hrstart);
            //console.info(client.id, 'Execution time (hr): %ds %dms', hrend[0], hrend[1]/1000000);
        };

        var stackInterval = function(){
            var stack = vrcsBufMap.get(client.id);
            if( stack == undefined){
                return;
            }

            var buf = stack.shift();
            if(buf == undefined){
                return;
            }

            //var jpeg = new Jpeg(buf, 512, 512, 'rgba');
            //jpeg.encode(function (jpeg_img) {
            //    try {
            //        if(client._socket._socket == undefined){
            //            console.log('INFO: Client already disconnected ', client.id);
            //        }else{
            //            client.send(jpeg_img);
            //        }
            //    }catch(err){
            //        console.log(err);
            //    }
            //});
        };

        var makeObject = function(buffer){
            var obj = {
                request_type : buffer.readFloatLE(0),
                volumePn : buffer.readFloatLE(4),
                frame : buffer.readFloatLE(8),
                rendering_type : buffer.readFloatLE(12),
                brightness : buffer.readFloatLE(16),
                positionZ : buffer.readFloatLE(20),
                transferOffset : buffer.readFloatLE(24),
                rotationX : buffer.readFloatLE(28),
                rotationY : buffer.readFloatLE(32)
            };
            console.log(obj);
            return obj;
        };

        var part = [];

        stream.on('data', function(data){
            part.push(data);
        });

        stream.on('end', function(){
            var param = makeObject(part[0]);
            if(param.request_type == 1) {
                var volumePn = param.volumePn;
                var volume = app.volumeMap.get(volumePn);

                if (volume == undefined) {
                    //console.log('volume index not exist');
                    return;
                } else {
                    var use = useMap.get(volumePn) == undefined ? 1 : useMap.get(volumePn) + 1;
                    useMap.set(volumePn, use);

                    var obj = {
                        volumePn: volumePn,
                        cudaInterval: undefined,
                        stackInterval : undefined,
                        frame: 0 };

                    //var cudaRender = new CudaRender();
                    //cudaRender.type = 0;
                    //cudaRender.textureFilePath = '/home/russa/git/vrcs/web/vrcs/public/upload/'+volume.save_name;
                    //cudaRender.init();

                    var cudaRender = new CudaRender(0, '/home/russa/git/vrcs/web/vrcs/public/upload/'+volume.save_name);
                    cudaRender.init();
                    console.log('CudaRender', cudaRender);
                    obj.cudaInterval = setInterval(cudaInterval, 10);
                    obj.stackInterval = setInterval(stackInterval, 1000 / frameList[obj.frame] );
                    streamMap.set(client.id, obj);
                    vrcsCudaMap.set(client.id, cudaRender);
                    vrcsBufMap.set(client.id, []);
                }
                console.log('connect byte stream ' + client.id + ' volume use ' + use);

            }else if(param.request_type == 2){
                var sum = param.frame;
                var obj = streamMap.get(client.id);
                var time = frameList[obj.frame];

                if( time - 5 > sum / 3  ){
                    //console.log('decrease frame');
                    obj.frame = obj.frame + 1 == frameList.length ? obj.frame : obj.frame + 1;
                }else if( time + 1 < sum /3 ){
                    //console.log('increase frame');
                    obj.frame = obj.frame-1 == -1 ? obj.frame : obj.frame - 1 ;
                }else{
                    //console.log('maintain frame');
                }
                //clearInterval(obj.cudaInterval);
                clearInterval(obj.stackInterval);
                //obj.cudaInterval = setInterval(cudaInterval, 1000 / frameList[obj.frame] );
                obj.stackInterval = setInterval(stackInterval, 1000 / frameList[obj.frame] );
                streamMap.set(client.id, obj);
            }else if(param.request_type == 3){
                console.log(param);
                var cudaRender = vrcsCudaMap.get(client.id);
                cudaRender.type = param.rendering_type;
                cudaRender.options.positionZ = param.positionZ;
                cudaRender.options.brightness = param.brightness;
                cudaRender.options.transferOffset = param.transferOffset;

                cudaRender.options.rotationX = param.rotationX;
                cudaRender.options.rotationY = param.rotationY;
                vrcsBufMap.set(client.id, []);
            }
        });

        stream.on('error', function(error){
            //console.log(error);
        });
    });

    client.on('close', function(stream, meta){
        console.log('close byte stream connection ' + client.id);
        var obj = streamMap.get(client.id);
        if(obj != undefined) {
            clearInterval(obj.cudaInterval);
            clearInterval(obj.stackInterval);
            streamMap.remove(client.id);

            var use = useMap.get(obj.volumePn) - 1;
            console.log('do remove ' + client.id + ' volume use ' + use);
            if(use == 0){
                app.volumeMap.remove(obj.volumePn);
                useMap.remove(obj.volumePn);
            }else{
                useMap.set(obj.volumePn, use);
            }
        }
        var cudaRender = vrcsCudaMap.get(client.id);
        if(cudaRender != undefined){
            cudaRender.finish();
            vrcsCudaMap.remove(client.id);
            vrcsBufMap.remove(client.id);
            console.log('do destory and free memory '+ client.id);
        }
    });

});

bs.on('error', function(error){
    //console.log(error);
});

//#######################################



//#######################################
// ~ socket bind message ( Implement socket room )

var socket_queue = [];
var streamUserCount = 0;

io.sockets.on('connection', function(socket){

    socket.on('join', function(){
        var clientId = socket.id;
        var message = {
            error : '',
            success : false,
            clientId : clientId
        };

        if(streamUserCount < 3){
            streamUserCount++;
            message.success = true;
        }else{
            socket_queue.push(clientId);
            message.error = 'Visitor limit';
        }

        //console.log('connect total count[ ' + streamUserCount + ' ] , socket id : ' + clientId);
        socket.emit('message', message);
    });

    socket.on('disconnect', function () {
        streamUserCount--;
        var clientId = socket_queue.shift();
        //console.log('disconnect total count[ ' + streamUserCount + ' ] , sockey id : ' + clientId);
        if(clientId != undefined){
            socket.broadcast.to(clientId).emit('user_disconnected');
        }
    });

});
//#######################################

// ~ server start
app.set('port', process.env.PORT || 3000);
var server = server.listen(app.get('port'), function() {
    debug('Express server listening on port ' + server.address().port);
});