#!/usr/bin/env node

//#######################################
// ~ load module and start server
var fs = require('fs-extra'); // FILE
var path = require('path');
var debug = require('debug')('vrcs');
var HashMap = require('hashmap').HashMap;

var Jpeg = require('jpeg').Jpeg; // JPEG
var Png = require('png').Png; // PNG

var app = require('../app');
var http = require('http');
var server = http.createServer(app);
var BinaryServer = require('binaryjs').BinaryServer; // BinaryJs (Byte stream)
var bs = BinaryServer({server : server}); // Start BinaryJs server
var io = require('socket.io').listen(server); // Socket.io
//#######################################


// TODO Deprcated Here load file and make queue multiple user
var queue = [];
queue.push(fs.readFileSync(path.join(__dirname, '../public/upload/[2014-11-27 20:00:00]_head2.den')));
queue.push(fs.readFileSync(path.join(__dirname, '../public/upload/03_test.den')));
queue.push(fs.readFileSync(path.join(__dirname, '../public/upload/05_test.den')));

//#######################################
// ~ Wait for new user connections ( Implement Byte stream )
var frameList = [ 30, 25, 20, 15, 10 ];
var streamMap = new HashMap();
var useMap = new HashMap();

function ab2str(buf) {
    return String.fromCharCode.apply(null, new Uint16Array(buf));
}

bs.on('connection', function(client){

    client.on('stream', function(stream, meta){
        console.log('byte stream connect attempt ' + client.id);

        var part = [];

        stream.on('data', function(data){
            part.push(data);
        });

        stream.on('end', function(){
            var volumePn = part[0].readInt32BE(0);
            var volume = app.volumeMap.get(volumePn);

            if(volume == undefined){
                console.log('volume index not exist');
                return;
            }else{
                var use = useMap.get(volumePn) == undefined ? 1 : useMap.get(volumePn)+1;
                useMap.set(volumePn, use);

                var obj = { volumePn : volumePn,
                            interval : undefined,
                            frame : frameList[0] };

                var sender = function() {

                    // TODO selection png or jpeg ( make this part function)
                    var jpeg = new Jpeg(queue[0], 512, 512, 'rgba');
                    jpeg.encode(function(jpeg_img){
                        client.send(jpeg_img)
                    });
/*
                    var png = new Png(queue[0], 512, 512, 'rgba');
                    png.encode(function(png_image){
                        client.send(png_image);
                    });
*/
                };

                obj.interval = setInterval(sender, obj.frame);
                streamMap.set(client.id, obj);
            }

            console.log('connect byte stream ' + client.id + ' volume use ' + use);
        });

        stream.on('error', function(error){
            console.log(error);
        });
    });

    client.on('close', function(stream, meta){
        console.log('close byte stream connection ' + client.id);
        var obj = streamMap.get(client.id);
        if(obj != undefined) {
            clearInterval(obj.interval);
            streamMap.remove(client.id);

            var use = useMap.get(obj.volumePn) - 1;
            console.log('do remove ' + client.id + ' volume use ' + use);
            if(use == 0){
                app.volumeMap.remove(obj.volumePn);
                useMap.remove(obj.volumePn);
            }else{
                useMap.set(obj.volumePn, use);
            }
        }
    });

});
//#######################################



//#######################################
// ~ socket bind message ( Implement socket room )

var socket_queue = [];
var streamUserCount = 0;

io.sockets.on('connection', function(socket){

    socket.on('join', function(){
        var clientId = socket.id;
        var message = {
            error : '',
            success : false,
            clientId : clientId
        };

        if(streamUserCount < 3){
            streamUserCount++;
            message.success = true;
        }else{
            socket_queue.push(clientId);
            message.error = 'Visitor limit';
        }

        console.log('connect total count[ ' + streamUserCount + ' ] , socket id : ' + clientId);
        socket.emit('message', message);
    });

    socket.on('disconnect', function () {
        streamUserCount--;
        var clientId = socket_queue.shift();
        console.log('disconnect total count[ ' + streamUserCount + ' ] , sockey id : ' + clientId);
        if(clientId != undefined){
            socket.broadcast.to(clientId).emit('user_disconnected');
        }
    });

});
//#######################################

// ~ server start
app.set('port', process.env.PORT || 3000);
var server = server.listen(app.get('port'), function() {
    debug('Express server listening on port ' + server.address().port);
});