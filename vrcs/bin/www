#!/usr/bin/env node
var debug = require('debug')('vrcs');
var app = require('../app');
var http = require('http');
// ~ binary js
var BinaryServer = require('binaryjs').BinaryServer;
var server = http.createServer(app);
// ~ socket io
var io = require('socket.io').listen(server);
// ~ file
var fs = require('fs-extra');
var path = require('path');
// ~ jpeg
var Jpeg = require('jpeg').Jpeg;
// ~ png
var Png = require('png').Png;

// ~ Start Binary.js server
var bs = BinaryServer({server : server});

// TODO Deprcated Here load file
var queue = [];

queue.push(fs.readFileSync(path.join(__dirname, '../public/upload/[2014-11-27 20:00:00]_head1.dat')));

var standard_frame = [ 30, 25, 20, 15, 10 ];
var volumeInterval;
var volumeFrame = standard_frame[0];
var count = 0;

// Wait for new user connections
bs.on('connection', function(client){
    // Incoming stream from browsers
    client.on('stream', function(stream, meta){

        var part = [];
        stream.on('data', function(data){
            part.push(data);
        });

        // when finished, set it as the background image
        stream.on('end', function(){
            var volumeIndex = part[0].readInt32BE(0);
            var volume = app.volumes[volumeIndex];

            if(volume == undefined){
                // TODO error handler
                console.log('volume index not exist');
                return;
            }else{
                console.log(volume.pn +': '+ volume.file_name + ': ' + volume.save_name);

                var sender = function() {
                    var jpeg = new Jpeg(queue[0], 512, 512, 'rgb');
                    jpeg.encode(function(jpeg_img){
                       //console.log('confirm jpeg', count++);
                        client.send(jpeg_img)
                    });

//                    var png = new Png(queue[0], 512, 512, 'rgba');
//                    png.encode(function(png_image){
//                        console.log('confirm png', count++);
//                        client.send(png_image);
//                    });
                };

                volumeInterval = setInterval(sender, volumeFrame);
            }
        });
    });

    // Close client
    client.on('close', function(stream, meta){
        clearInterval(volumeInterval);
    });
});

// ~ socket bind message
var rooms = []; // total count web clients

io.sockets.on('connection', function(socket){

    socket.on('join', function(data){
        var message = {
            error : '',
            success : false
        };
        // ~ add room information
        if(rooms.indexOf(data.room) == -1){
            rooms.push(data.room);
        }
        // ~ data.room : volumeIndex
        var totalCount = findClientsSocket().length;
        console.log('Total count: ', totalCount);
        if( totalCount < 4){
            socket.join(data.room);
            message.success = true;
        }else{
            message.error = 'Visitor limit';
        }

        socket.emit('message', message);
    });

});

app.set('port', process.env.PORT || 3000);
var server = server.listen(app.get('port'), function() {
    debug('Express server listening on port ' + server.address().port);
});

function findClientsSocket() {
    var res = [];
    var delRooms = [];
    //console.log('Start Rooms: '+ rooms);
    for (var i in rooms) {
        var roomId = rooms[i];
        var room = io.sockets.adapter.rooms[roomId];
        if(room == undefined){
            delRooms.push(roomId);
            continue;
        }
        for (var id in room) {
            var clients = io.sockets.adapter.nsp.connected[id];
            res.push(clients);
        }
    }
    // Delete room
    for(var i in delRooms){
        //console.log('del ', delRooms[i])
        rooms.splice(rooms.indexOf(roomId), 1);
    }
    //console.log('End Rooms: '+ rooms);
    return res;
}